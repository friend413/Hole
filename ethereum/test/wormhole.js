const Wormhole = artifacts.require("Wormhole");
const WrappedAsset = artifacts.require("WrappedAsset");
const ERC20 = artifacts.require("ERC20PresetMinterPauser");

// Taken from https://medium.com/fluidity/standing-the-time-of-test-b906fcc374a9
advanceTimeAndBlock = async (time) => {
    await advanceTime(time);
    await advanceBlock();

    return Promise.resolve(web3.eth.getBlock('latest'));
}

advanceTime = (time) => {
    return new Promise((resolve, reject) => {
        web3.currentProvider.send({
            jsonrpc: "2.0",
            method: "evm_increaseTime",
            params: [time],
            id: new Date().getTime()
        }, (err, result) => {
            if (err) {
                return reject(err);
            }
            return resolve(result);
        });
    });
}

advanceBlock = () => {
    return new Promise((resolve, reject) => {
        web3.currentProvider.send({
            jsonrpc: "2.0",
            method: "evm_mine",
            id: new Date().getTime()
        }, (err, result) => {
            if (err) {
                return reject(err);
            }
            const newBlockHash = web3.eth.getBlock('latest').hash;

            return resolve(newBlockHash)
        });
    });
}

/*
    The VAA test fixtures are generated by bridge/cmd/vaa-test.
 */

contract("Wormhole", function () {
    it("should use master wrapped asset", async function () {
        let bridge = await Wormhole.deployed();
        let wa = await bridge.wrappedAssetMaster.call();
        assert.equal(wa, WrappedAsset.address)
    });

    it("should transfer tokens in on valid VAA", async function () {
        let bridge = await Wormhole.deployed();

        // User locked an asset on the foreign chain and the VAA proving this is transferred in.
        await bridge.submitVAA("0x01000000000100454e7de661cd4386b1ce598a505825f8ed66fbc6a608393bae6257fef7370da27a2068240a902470bed6c0b1fa23d38e5d5958e2a422d59a0217fbe155638ed600000007d010000000380102020104000000000000000000000000000000000000000000000000000000000000000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c1010000000000000000000000000347ef34687bdc9f189e87a9200658d9c40e9988080000000000000000000000000000000000000000000000000de0b6b3a7640000")
        // Expect user to have a balance of a new wrapped asset
        // submitVAA has automatically created a new WrappedAsset for the foreign asset that has been transferred in.
        // We know the address because deterministic network. A user would see the address in the submitVAA tx log.
        let wa = new WrappedAsset("0xC3697aaf5B3D354214548248710414812099bc93");
        assert.equal(await wa.assetChain(), 1)
        // Remote asset's contract address.
        assert.equal(await wa.assetAddress(), "0x0000000000000000000000000347ef34687bdc9f189e87a9200658d9c40e9988")
        // Account that the user requests the transfer to.
        let balance = await wa.balanceOf("0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1");
        assert.equal(balance, "1000000000000000000");
    });

    it("should not accept the same VAA twice", async function () {
        let bridge = await Wormhole.deployed();
        try {
            await bridge.submitVAA("0x01000000000100454e7de661cd4386b1ce598a505825f8ed66fbc6a608393bae6257fef7370da27a2068240a902470bed6c0b1fa23d38e5d5958e2a422d59a0217fbe155638ed600000007d010000000380102020104000000000000000000000000000000000000000000000000000000000000000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c1010000000000000000000000000347ef34687bdc9f189e87a9200658d9c40e9988080000000000000000000000000000000000000000000000000de0b6b3a7640000");
        } catch (e) {
            assert.equal(e.reason, "VAA was already executed")
            return
        }
        assert.fail("did not fail")
    });

    it("should burn tokens on lock", async function () {
        let bridge = await Wormhole.deployed();
        // Expect user to have a balance
        let wa = new WrappedAsset("0xC3697aaf5B3D354214548248710414812099bc93")

        await bridge.lockAssets(wa.address, "500000000000000000", "0x0", 4, 2, false);
        let balance = await wa.balanceOf("0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1");

        // Expect user balance to decrease
        assert.equal(balance, "500000000000000000");

        // Expect contract balance to be 0 since tokens have been burned
        balance = await wa.balanceOf(bridge.address);
        assert.equal(balance, "0");
    });

    it("should transfer tokens in and out", async function () {
        let bridge = await Wormhole.deployed();
        let token = await ERC20.new("Test Token", "TKN");

        await token.mint("0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1", "1000000000000000000000000000");
        // Expect user to have a balance
        assert.equal(await token.balanceOf("0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1"), "1000000000000000000000000000");

        // Approve bridge
        await token.approve(bridge.address, "1000000000000000000000000000");

        // Transfer of that token out of the contract should not work
        let threw = false;
        try {
            await bridge.submitVAA("0x01000000000100078f0fe9406808b1e5003867ab74aa2085153b7735b329640d275ea943dd115d00e356c6d343142d9190872c11d2de898d075cea7f4e85ff2188af299e26a14200000007d010000000380102020104000000000000000000000000000000000000000000000000000000000000000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c102000000000000000000000000d833215cbcc3f914bd1c9ece3ee7bf8b14f841bb080000000000000000000000000000000000000000000000000de0b6b3a7640000");
        } catch (e) {
            threw = true;
        }
        assert.isTrue(threw);

        // Lock assets
        let ev = await bridge.lockAssets(token.address, "1000000000000000000000000000", "0x1230000000000000000000000000000000000000000000000000000000000000", 3, 3, false);

        // Check that the lock event was emitted correctly
        assert.lengthOf(ev.logs, 1)
        assert.equal(ev.logs[0].event, "LogTokensLocked")
        assert.equal(ev.logs[0].args.target_chain, "3")
        assert.equal(ev.logs[0].args.token_chain, "2")
        assert.equal(ev.logs[0].args.token, "0x000000000000000000000000d833215cbcc3f914bd1c9ece3ee7bf8b14f841bb")
        assert.equal(ev.logs[0].args.sender, "0x00000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c1")
        assert.equal(ev.logs[0].args.recipient, "0x1230000000000000000000000000000000000000000000000000000000000000")
        assert.equal(ev.logs[0].args.amount, "1000000000000000000")

        // Check that the tokens were transferred to the bridge
        assert.equal(await token.balanceOf("0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1"), "0");
        assert.equal(await token.balanceOf(bridge.address), "1000000000000000000000000000");

        // Transfer this token back - This also checks decimal realignment
        await bridge.submitVAA("0x01000000000100078f0fe9406808b1e5003867ab74aa2085153b7735b329640d275ea943dd115d00e356c6d343142d9190872c11d2de898d075cea7f4e85ff2188af299e26a14200000007d010000000380102020104000000000000000000000000000000000000000000000000000000000000000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c102000000000000000000000000d833215cbcc3f914bd1c9ece3ee7bf8b14f841bb080000000000000000000000000000000000000000000000000de0b6b3a7640000");
        assert.equal(await token.balanceOf("0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1"), "1000000000000000000000000000");
        assert.equal(await token.balanceOf(bridge.address), "0");
    });

    it("should accept validator set change", async function () {
        let bridge = await Wormhole.deployed();

        // Push time by 1000
        await advanceTimeAndBlock(1000);
        let ev = await bridge.submitVAA("0x01000000000100a33c022217ccb87a5bc83b71e6377fff6639e7904d9e9995a42dc0867dc2b0bc5d1aacc3752ea71cf4d85278526b5dd40b0343667a2d4434a44cbf7844181a1000000007d0010000000101e06a9adfeb38a8ee4d00e89307c016d0749679bd")
        assert.lengthOf(ev.logs, 1)
        assert.equal(ev.logs[0].event, "LogGuardianSetChanged")

        // Expect guardian set to transition to 1
        assert.equal(await bridge.guardian_set_index(), 1);
    });

    it("should not accept guardian set change from old guardians", async function () {
        let bridge = await Wormhole.deployed();

        // Test update guardian set VAA from guardian set 0; timestamp 2000
        let threw = false;
        try {
            await bridge.submitVAA("0x01000000000100d90d6f9cbc0458599cbe4d267bc9221b54955b94cb5cb338aeb845bdc9dd275f558871ea479de9cc0b44cfb2a07344431a3adbd2f98aa86f4e12ff4aba061b7f00000007d00100000001018575df9b3c97b4e267deb92d93137844a97a0132")
        } catch (e) {
            threw = true;
            assert.equal(e.reason, "only the current guardian set can change the guardian set")
        }
        assert.isTrue(threw, "old guardian set could make changes")
    });

    it("should time out guardians", async function () {
        let bridge = await Wormhole.deployed();

        // Test VAA from guardian set 0; timestamp 1000
        await bridge.submitVAA("0x0100000000010034890d1c1aa2455d083602996d924ca9ba2fd9641dcdaa3b0811c9ed37e831a8433b40b0f0779fa16be2daaf53ede378530a135b68ac95814c9d25023a29580e01000003e810000000380102020104000000000000000000000000000000000000000000000000000000000000000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c1010000000000000000000000000347ef34687bdc9f189e87a9200658d9c40e9988080000000000000000000000000000000000000000000000000de0b6b3a7640000")

        await advanceTimeAndBlock(1000);

        // Test VAA from guardian set 0; timestamp 2000 - should not work anymore
        let threw = false;
        try {
            await bridge.submitVAA("0x010000000001005a55b73ff79bc3cc39bec075ae28ae8351eee1428a7701f0d47fec5736bcfd9e158b49e6282678c425aed8185233ea4ef033af33bd450a77a46ddbadf3ea09ba00000007d010000000380102020105000000000000000000000000000000000000000000000000000000000000000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c1010000000000000000000000000347ef34687bdc9f189e87a9200658d9c40e9988080000000000000000000000000000000000000000000000000de0b6b3a7640000")
        } catch (e) {
            threw = true;
            assert.equal(e.reason, "guardian set has expired")
        }
        assert.isTrue(threw, "guardian set did not expire")

        // Test same transaction with guardian set 1; timestamp 2000
        await bridge.submitVAA("0x01000000010100958a39752b14ab62a3dcdb37a8642c4ca1085c6ac77205a462ee5bb3650c92407675729615f69255fc150835621e96c917e68929efb975db9647636543c710f200000007d010000000380102020105000000000000000000000000000000000000000000000000000000000000000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c1010000000000000000000000000347ef34687bdc9f189e87a9200658d9c40e9988080000000000000000000000000000000000000000000000000de0b6b3a7640000")
    });

    it("mismatching guardian set and signature should not work", async function () {
        let bridge = await Wormhole.deployed();

        // Test VAA signed by guardian set 0 but set guardian set index to 1
        let threw = false;
        try {
            await bridge.submitVAA("0x01000000010100724a1d2cda45da3cf38f9e0eaef01742210f4deabf9b9d4b20127f6a200a94805928e26ae5f5ab8c3e1cb6d5231d4c48aacae0841513fbd3d9d430be7145db8200000007d010000000390102020105000000000000000000000000000000000000000000000000000000000000000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c1010000000000000000000000000347ef34687bdc9f189e87a9200658d9c40e9988080000000000000000000000000000000000000000000000000de0b6b3a7640000")
        } catch (e) {
            threw = true;
            assert.equal(e.reason, "VAA signature invalid")
        }
        assert.isTrue(threw, "invalid signature accepted")
    });

    it("quorum should be honored", async function () {
        let bridge = await Wormhole.deployed();

        // Update to validator set 2 with 6 signers
        await bridge.submitVAA("0x010000000101007a8681fbb4eb93fe71d2608bacdd6ac8d7f07987d531435fc4e0e9224fcf5d087991860eb61b73671db864e7b33894ec82f7ffb17ba5a888712fb6be11df4b030100000fa0010000000206befa429d57cd18b7f8a4d91a2da9ab4af05d0fbee06a9adfeb38a8ee4d00e89307c016d0749679bd8575df9b3c97b4e267deb92d93137844a97a01320427cda59902dc6eb0c1bd2b6d38f87c5552b348bfea822f75c42e1764c791b8fe04a7b10ddb38572f5fe0b158147e7260f14062556afc94eece55ff")

        // Test VAA signed by only 3 signers
        let threw = false;
        try {
            await bridge.submitVAA("0x01000000020300e94bec8a17bd313522cdfea30cec5406a41a4cc4b6ec416a633ebe3aca070ae448e370e0a2e7c67fed04a2b825f56cf226c76e6ecd2e71865642393bf729dad80101ccf89506bef58d8cb12baabd60e3304cfb90ef0ef0657caba9c37ffa0d34a54c3aacd1a475ef4c72f24e8d9ce1e2de51e580ce85b18356436b6cda9e2ae9abc0010285f0d3c0d1cd421ce0ae515db1ac3b623c17d4702564971932fb9925c0506fc76e43a7283c712ee680cf058c3c447653c352ca9827b1780e1fc88a61540092d90100000fa010000000390102020105000000000000000000000000000000000000000000000000000000000000000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c1010000000000000000000000000347ef34687bdc9f189e87a9200658d9c40e9988080000000000000000000000000000000000000000000000000de0b6b3a7640000")
        } catch (e) {
            threw = true;
            assert.equal(e.reason, "no quorum")
        }
        assert.isTrue(threw, "accepted only 3 signatures")

        // Test VAA signed by 5 signers (all except i=3)
        await bridge.submitVAA("0x01000000020500e94bec8a17bd313522cdfea30cec5406a41a4cc4b6ec416a633ebe3aca070ae448e370e0a2e7c67fed04a2b825f56cf226c76e6ecd2e71865642393bf729dad80101ccf89506bef58d8cb12baabd60e3304cfb90ef0ef0657caba9c37ffa0d34a54c3aacd1a475ef4c72f24e8d9ce1e2de51e580ce85b18356436b6cda9e2ae9abc001033e9b4ff5fb545e964e907349e3dab0057c408c832bb31fb76fae7f81c3e488ea4897ce14db61c46d1169bd64b449498b1a18dee4de0ef2038b1c7e3a4a0239a0010432eac9532a4c0ce279d6a3018a5ea0d74402eb6969df5d444f20e0cca66d3b4c53e41cb18648f64af100c7410692e83fa16e5696b1f5f0d517653b003e22689800055859330bd1fee76d99728803fa26d739e494e1a232f5658150c2a2c97e1c9722793bdd83bd7cbb4a39b587b45093ee76187c72dfd68d64b7c0abc32bfef5d55c0000000fa010000000390102020105000000000000000000000000000000000000000000000000000000000000000000000000000000000090f8bf6a479f320ead074411a4b0e7944ea8c9c1010000000000000000000000000347ef34687bdc9f189e87a9200658d9c40e9988080000000000000000000000000000000000000000000000000de0b6b3a7640000")
    });

    it("should correctly adjust decimals", async function () {
        let bridge = await Wormhole.deployed();
        let token = await ERC20.new("Test Token", "TKN");

        await token.mint("0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1", "25000000000000000000000000000000000000");

        // Approve bridge
        await token.approve(bridge.address, "25000000000000000000000000000000000000");

        // Lock assets
        let ev = await bridge.lockAssets(token.address, "2000000000000000003", "0x1230000000000000000000000000000000000000000000000000000000000000", 3, 3, false);

        // Check that the correct amount was logged
        assert.lengthOf(ev.logs, 1)
        assert.equal(ev.logs[0].event, "LogTokensLocked")
        assert.equal(ev.logs[0].args.amount, "2000000000")
        assert.equal(ev.logs[0].args.token_decimals, "9")

        ev = await bridge.lockAssets(token.address, "2000000000000000000", "0x1230000000000000000000000000000000000000000000000000000000000000", 3, 3, false);
        // Check that the correct amount was logged
        assert.lengthOf(ev.logs, 1)
        assert.equal(ev.logs[0].event, "LogTokensLocked")
        assert.equal(ev.logs[0].args.amount, "2000000000")

        await bridge.lockAssets(token.address, "18446744069709551615000000000", "0x1230000000000000000000000000000000000000000000000000000000000000", 3, 3, false);
        let threw = false;
        try {
            await bridge.lockAssets(token.address, "1000000000", "0x1230000000000000000000000000000000000000000000000000000000000000", 3, 3, false);
        } catch (e) {
            threw = true;
            assert.equal(e.reason, "bridge balance would exceed maximum")
        }
        assert.isTrue(threw, "accepted total bridge balance > MAX_U64")
    });

    it("should refund dust", async function () {
        let bridge = await Wormhole.deployed();
        let token = await ERC20.new("Test Token", "TKN");

        await token.mint("0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1", "5000000100");

        // Approve bridge
        await token.approve(bridge.address, "5000000100");

        // Lock assets
        let ev = await bridge.lockAssets(token.address, "1000000005", "0x1230000000000000000000000000000000000000000000000000000000000000", 3, 3, false);

        // Check that dust was not subtracted
        assert.lengthOf(ev.logs, 1)
        assert.equal(ev.logs[0].event, "LogTokensLocked")
        assert.equal(ev.logs[0].args.amount, "1")
        assert.equal(await token.balanceOf("0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1"), "4000000095");

        // Lock assets
        ev = await bridge.lockAssets(token.address, "1000000005", "0x1230000000000000000000000000000000000000000000000000000000000000", 3, 3, true);

        // Check that dust was refunded
        assert.lengthOf(ev.logs, 1)
        assert.equal(ev.logs[0].event, "LogTokensLocked")
        assert.equal(ev.logs[0].args.amount, "1")
        assert.equal((await token.balanceOf("0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1")).toString(), "3000000095");
    });
});
